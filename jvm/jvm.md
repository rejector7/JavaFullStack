
## 不同gc策略比较

* SerialGC
  * 策略：单线程执行GC，适用于单核处理器环境或有限的资源下的小型应用。
  * -XX:+UseSerialGC
  * 优劣：简单高效（在资源有限的环境下）；在GC时会暂停所有应用线程，不适合多处理器环境或要求低延迟的应用。
  * 适用场景：客户端模式的小型应用、简单的命令行程序。
* ParallelGC（Parallel Scavenge）
  * 策略：多线程并行地进行GC，以提高吞吐量。
  * -XX:+UseParallelGC，是JDK 8的默认GC。
  * 优劣：适用于多核CPU，通过并行执行来缩短GC暂停时间；但在GC执行期间，应用线程仍需要暂停，可能不适合对停顿时间敏感的应用。
  * 适用场景：多核服务器环境，注重吞吐量而不是停顿时间的应用。
* CMS（并发标记清除）GC
  * 策略：尽量减少应用暂停时间的GC，通过并发标记和清除步骤来实现。
    * youngGen：ParNew
    * OldGen：CMS
  * -XX:+UseConcMarkSweepGC
  * 优劣：并发执行的大部分GC工作，减少了暂停时间，减少停顿时间，适合互联网应用；但是会产生较多的内存碎片，且CPU资源占用较高。
  * 适用场景：延迟敏感的、中等至大型的Web应用。
* G1GC（Garbage-First）
  * 策略：面向服务器的GC，旨在提供一个平衡了高吞吐量和低延迟的垃圾收集器。将堆划分为多个小块（Region），并根据每块的价值（即回收空间大小与回收所需时间的比值）来优先回收。
  * -XX:+UseG1GC，-XX:MaxGCPauseMillis。从Java 9开始，G1成为了默认的垃圾收集器。
  * 适用于拥有大内存的多核服务器，能够预测停顿时间（-XX:MaxGCPauseMillis目标），但在某些情况下可能会有较高的CPU消耗。
  * 适用场景：大内存、多核服务器，需要维持低延迟同时要求高吞吐量的应用。
* ZGC（JDK 11+）
* Shenandoah GC（JDK 12+）

## jvm调优方法

* 调整新生代&老年代大小
  * -XX:NewRatio=n、-Xmn<size>、-XX:NewSize=<size>、-XX:MaxNewSize=<size>
  * 调大新生代&调小老年代：短命对象较多。
  * 调小新生代&调大老年代：长命对象较多。
 
* 调整对象分配位置
  * -XX:PretenureSizeThreshold=<size>
  * 当对象的大小超过这个设定的阈值时，这个对象会被直接分配到老年代，而不是新生代（Young Generation）。这个参数主要是为了避免在新生代中分配大对象，因为大对象会迅速占用新生代空间，导致频繁的垃圾回收。
  * 这个参数只在使用Serial和ParNew新生代垃圾收集器时有效。如果你使用的是G1或Parallel Scavenge（默认的垃圾收集器），这个参数不会有任何效果。
* 调整gc策略

## 新生代&老年代大小优化策略

在考虑调整新生代大小时，我们会面临吞吐量和停顿时间之间的权衡。以下是一些更具体的解释和场景：

### 优化停顿时间

- 对于关注停顿时间的应用，理论上增大新生代空间可以减少新生代GC（Minor GC）的频率，因为更多的短命对象可以在新生代中存活并随Minor GC一起被清理，从而减少每次GC的停顿时间。
- 但是，如果新生代过大，当发生Minor GC时，可能会因为要检查、复制更多的对象而导致每次GC的停顿时间其实增长了。
- 所以，增大新生代并不总是能优化停顿时间，要根据具体的应用行为来决定。

### 增加吞吐量

- 吞吐量通常是指CPU用于运行应用程序代码相对于运行GC代码的时间比。在某些情况下，增大新生代可以减少Minor GC的频率，这意味着应用程序有更长的时间段可以不被GC中断，理论上可以提高吞吐量。
- 但是，如果新生代设置过大，导致老年代空间相对减小，可能会增加老年代GC的频率，老年代GC通常会停顿更长的时间，这反而可能降低吞吐量。

### 重要的是平衡

调整新生代大小影响的是新生代GC与老年代GC之间的频率和性能平衡：

- 如果新生代太小，那么对象较快晋升到老年代，可能导致频繁的Full GC，这会严重影响应用性能。
- 如果新生代太大，虽然频繁的Minor GC可以减少，但当它发生时，可能导致更大的停顿时间，且老年代变小，可能导致老年代更频繁地进行更耗时的GC。

每个应用都有其独特的特性，比如对象的创建速率、存活率以及晋升老年代的速率等，因此最佳的新生代大小和比例依赖于具体的应用和工作负荷。实际中应该通过监控、测试和调整来找到最适合当前应用的配置，而不是期望通过某个通用的设置来优化所有性能指标。

## G1 GC 策略
G1垃圾收集器（Garbage-First Garbage Collector）在管理Java堆内存方面采取了与其他垃圾收集器（如Parallel GC或CMS）不同的方法。G1 GC的设计目标是兼顾高吞吐量和低延迟，特别适用于多核机器和大内存环境。以下是G1 GC如何控制对象分配到老年代，以及G1中的Region概念的详细解释：

### Region（区域）

G1 GC引入了一个创新的概念：将整个堆分割成多个大小相等的连续区域（Region）。这些Region可以是以下几种类型之一：

- Eden
- Survivor
- Old

这种划分方式使得G1 GC更加灵活，因为它不再需要事前固定新生代和老年代的大小，而是能够根据应用程序的实际行为动态调整。每种区域类型的Region数目都是变化的，G1会根据垃圾收集的需要动态调整。

### 对象分配机制

新创建的对象首先被分配到Eden Region。当进行垃圾收集时，存活的对象会从Eden Region被移动（复制）到Survivor Region，或者直接晋升到Old Region，这依赖于对象的存活年龄和Region的剩余空间。

G1 GC通过维护一个名为“Remembered Set”的数据结构来跟踪不同Region之间的引用，这确保了即使对象分散在不同的Region中，G1 GC也能准确地进行垃圾收集。

### 老年代对象控制

G1 GC控制对象晋升到老年代的主要机制如下：

1. **动态年龄判定**：在G1中，并没有固定的年龄阈值来决定对象是否应该晋升到老年代。G1根据Survivor Region中对象的存活状况和容量动态调整晋升阈值。
   
2. **Region的角色转换**：根据程序运行情况，G1可以动态调整不同类型Region的数量。这意味着G1可以按需增加或减少老年代的Region数量，从而控制老年代的大小。

3. **混合GC（Mixed GC）**：G1 GC采用一种名为“混合收集”的策略回收老年代中的垃圾，这种方式既可以回收新生代，也可以选定一部分老年代Region进行并发回收。通过选择性地回收老年代中的Region，G1能够更好地控制响应时间，以达到低延迟的目标。

### Region的作用

1. **提升灵活性**：通过将堆分割成多个Region，G1 GC可以根据应用的实际内存使用和GC性能需求，高效且灵活地管理内存。
   
2. **减少停顿时间**：G1 GC能够设置期望的停顿时间目标（例如，通过`-XX:MaxGCPauseMillis`参数），它通过优先回收那些包含最多可回收对象的Region来实现这一目标，从而减少GC停顿时间，提高了应用的响应能力。
   
3. **提升收集效率**：通过并发的方式回收选定的老年代Region，G1可以在应用运行时回收内存，避免了长时间的全堆停顿。

### 总结

G1 GC通过动态Region的概念和灵活的垃圾收集策略，提供了一种平衡高吞吐量与低延迟的垃圾回收解决方案。Region机制让G1 GC在对象分配和晋升到老年代的控制上更加灵活高效，同时通过混合GC减少了应用的停顿时间，提高了性能。
